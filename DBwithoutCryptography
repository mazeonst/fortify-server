from fastapi import FastAPI, HTTPException, Body
from pydantic import BaseModel
from sqlalchemy import create_engine, Column, String, Table, MetaData, Integer, ForeignKey
from sqlalchemy.orm import sessionmaker, declarative_base, relationship
from sqlalchemy.future import select
import hashlib
import random
import string

DATABASE_URL = "sqlite:///./test.db"

# Создаем подключение к базе данных
engine = create_engine(DATABASE_URL, echo=True)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# Определяем модель пользователя
class User(Base):
    __tablename__ = "users"
    seed_hash = Column(String, primary_key=True, index=True)
    passwords = relationship("Password", back_populates="user")

# Определяем модель пароля
class Password(Base):
    __tablename__ = "passwords"
    id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    seed_hash = Column(String, ForeignKey("users.seed_hash"))
    password_name = Column(String, index=True)
    password_value = Column(String)
    service = Column(String)
    email = Column(String)
    username = Column(String)
    user = relationship("User", back_populates="passwords")

# Создаем таблицы
Base.metadata.create_all(bind=engine)

# Создаем FastAPI приложение
app = FastAPI()

# Функция для хэширования сид-фразы
def hash_seed(seed: str) -> str:
    return hashlib.sha256(seed.encode()).hexdigest()

# Функция для генерации случайной сид-фразы
def generate_seed(length: int = 16) -> str:
    return ''.join(random.choices(string.ascii_letters + string.digits, k=length))

class SeedRequest(BaseModel):
    seed: str

# Pydantic модель для данных пользователя
class PasswordData(BaseModel):
    password_name: str
    password_value: str
    service: str
    email: str
    username: str

@app.post("/register")
async def register_user():
    seed = generate_seed()
    seed_hash = hash_seed(seed)
    db = SessionLocal()
    try:
        # Проверяем, существует ли пользователь
        existing_user = db.query(User).filter(User.seed_hash == seed_hash).first()
        if existing_user:
            raise HTTPException(status_code=400, detail="Пользователь с такой сид-фразой уже существует")
        # Создаем нового пользователя
        new_user = User(seed_hash=seed_hash)
        db.add(new_user)
        db.commit()
        return {"message": "Пользователь зарегистрирован", "seed": seed}
    finally:
        db.close()

@app.post("/login")
async def login_user(seed_data: SeedRequest):
    seed = seed_data.seed
    seed_hash = hash_seed(seed)
    db = SessionLocal()
    try:
        # Проверяем, существует ли пользователь
        user = db.query(User).filter(User.seed_hash == seed_hash).first()
        if not user:
            raise HTTPException(status_code=404, detail="Пользователь не найден")
        return {"message": "Вход выполнен"}
    finally:
        db.close()


@app.post("/save_password")
async def save_password(seed: str = Body(...), password_data: PasswordData = Body(...)):
    seed_hash = hash_seed(seed)
    db = SessionLocal()
    try:
        # Проверяем, существует ли пользователь
        user = db.query(User).filter(User.seed_hash == seed_hash).first()
        if not user:
            raise HTTPException(status_code=404, detail="Пользователь не найден")

        # Получаем количество уже сохраненных паролей для данного пользователя
        password_count = db.query(Password).filter(Password.seed_hash == seed_hash).count()
        password_name = f"Password_{password_count + 1}"  # Присваиваем новый порядковый номер

        # Сохраняем новый пароль с порядковым именем
        new_password = Password(
            seed_hash=seed_hash,
            password_name=password_name,
            password_value=password_data.password_value,
            service=password_data.service,
            email=password_data.email,
            username=password_data.username
        )
        db.add(new_password)  # Добавляем новый пароль в базу данных
        db.commit()  # Сохраняем изменения
        return {"message": "Пароль сохранен", "password_name": password_name}
    finally:
        db.close()


@app.get("/get_passwords")
async def get_passwords(seed: str):
    seed_hash = hash_seed(seed)
    db = SessionLocal()
    try:
        # Проверяем, существует ли пользователь
        user = db.query(User).filter(User.seed_hash == seed_hash).first()
        if not user:
            raise HTTPException(status_code=404, detail="Пользователь не найден")

        # Получаем все пароли пользователя и сортируем их по порядковому номеру в обратном порядке
        passwords = db.query(Password).filter(Password.seed_hash == seed_hash).order_by(Password.id.desc()).all()

        return {"passwords": [{
            "password_name": pwd.password_name,
            "password_value": pwd.password_value,
            "service": pwd.service,
            "email": pwd.email,
            "username": pwd.username
        } for pwd in passwords]}
    finally:
        db.close()


